package com.thoughtworks.railroad.controller;import java.util.ArrayList;import java.util.List;import com.thoughtworks.railroad.exception.NoSuchPathException;import com.thoughtworks.railroad.exception.NoSuchVertexException;import com.thoughtworks.railroad.exception.WrongInputException;import com.thoughtworks.railroad.model.GraphBuilder;import com.thoughtworks.railroad.model.Path;import com.thoughtworks.railroad.model.Vertex;import com.thoughtworks.railroad.model.condition.ExactCondition;import com.thoughtworks.railroad.model.condition.MaxCondition;import com.thoughtworks.railroad.model.condition.MaxDistanceCondition;import com.thoughtworks.railroad.model.graph.IGraph;/** * Controller of the application responsible for redirecting to the * responsibility to the appropriate methods *  * @author Narasimman *  */public class Controller {  private static IGraph graph;  private enum PATH_CONDITION {    MAX_STOPS, EXACT_STOPS, MAX_DISTANCE  }  private Controller() {    if (graph == null) {      graph = GraphBuilder.getDirectedGraph();    }  }  /**   * Static method that returns an intance of the controller   *    * @return   */  public static Controller getController() {    return new Controller();  }  public IGraph getGraph() {    return graph;  }  /**   * get the shortest path for the given path command   *    * @param inputVertices   * @return length of the shortest path   */  public String getShortestPath(String inputVertices) {    String nodes[] = inputVertices.split("-");    if (nodes.length < 2) {      throw new WrongInputException("ERROR: Shortest Path: " + inputVertices);    }    String from = nodes[0].trim().toUpperCase();    Vertex start = new Vertex(from);    String to = nodes[1].trim().toUpperCase();    Vertex end = new Vertex(to);    Path shortest = null;    try {      shortest = graph.getShortestPath(start, end);    } catch (NoSuchPathException e) {      return e.getMessage();    } catch (NoSuchVertexException e) {      return e.getMessage();    }    return String.valueOf(shortest.getDistance());  }  /**   * get the distance between the nodes Input format : A-C , C-C   *    * @param inputPath   * @return   */  public String getDistance(String inputPath) {    String nodes[] = inputPath.split("-");    if (nodes.length < 2) {      throw new WrongInputException("Distance: " + inputPath);    }    String from = nodes[0].trim().toUpperCase();    Vertex start = new Vertex(from);    Vertex[] stops = new Vertex[nodes.length - 1];    for (int i = 1; i < nodes.length; ++i) {      String stop = nodes[i].trim().toUpperCase();      stops[i - 1] = new Vertex(stop);    }    String distance = null;    try {      distance = graph.calculateDistance(start, stops);    } catch (NoSuchPathException e) {      return e.getMessage();    } catch (NoSuchVertexException e) {      return e.getMessage();    }    return distance;  }  /**   * get the length of the path with exactly the number of stops mentioned Input   * format : C-C and an integer   *    * @param inputVertices   * @param stops   * @return number of paths from source to destination   */  public String getPathsWithExactStops(String inputVertices, int stops) {    List<Vertex> nodes = parseInputCommand(inputVertices);    List<Path> paths = new ArrayList<Path>();    try {      paths = graph.getAllPaths(nodes.get(0), nodes.get(1), new ExactCondition(          stops), new MaxCondition(stops));    } catch (NoSuchPathException e) {      return e.getMessage();    } catch (NoSuchVertexException e) {      return e.getMessage();    }    return String.valueOf(paths.size());  }  /**   * get the number of paths atmost the max stops specified   *    * @param inputVertices   * @param stops   * @return number of paths   */  public String getPathsWithMaxStops(String inputVertices, int stops) {    List<Vertex> nodes = parseInputCommand(inputVertices);    List<Path> paths = new ArrayList<Path>();    try {      paths = graph.getAllPaths(nodes.get(0), nodes.get(1), new MaxCondition(          stops), new MaxCondition(graph.getNumberOfVertices()));    } catch (NoSuchPathException e) {      return e.getMessage();    } catch (NoSuchVertexException e) {      return e.getMessage();    }    return String.valueOf(paths.size());  }  /**   * get the number of trips with distance less than the threshold   *    * @param inputVertices   * @param distance   * @return number of valid trips   */  public String getPathsWithMaxDistance(String inputVertices, int distance) {    List<Vertex> nodes = parseInputCommand(inputVertices);    List<Path> paths = new ArrayList<Path>();    try {      paths = graph.getAllPaths(nodes.get(0), nodes.get(1),          new MaxDistanceCondition(distance),          new MaxDistanceCondition(distance));    } catch (NoSuchPathException e) {      return e.getMessage();    } catch (NoSuchVertexException e) {      return e.getMessage();    }    return String.valueOf(paths.size());  }  /**   * Parses the input command given as a string if valid input, returns the   * vertices objects   *    * @param command   * @return   */  private List<Vertex> parseInputCommand(String command) {    String nodes[] = command.split("-");    if (nodes.length < 2) {      throw new WrongInputException("Path: " + command);    }    String from = nodes[0].trim().toUpperCase();    Vertex start = new Vertex(from);    String to = nodes[1].trim().toUpperCase();    Vertex end = new Vertex(to);    List<Vertex> vertices = new ArrayList<Vertex>();    vertices.add(start);    vertices.add(end);    return vertices;  }  /**   * get the number of paths given the condition The conditions are given in an   * enum   *    * @param command   * @return   */  public String getPaths(String command) {    String[] commandArray = command.split(",");    if (commandArray.length != 3) {      throw new WrongInputException(command + " is wrong route input.");    }    String type = commandArray[0].trim();    int max = Integer.parseInt(commandArray[1].trim());    String path = commandArray[2];    if (type.equalsIgnoreCase(PATH_CONDITION.MAX_STOPS.toString())) {      return getPathsWithMaxStops(path, max);    } else if (type.equalsIgnoreCase(PATH_CONDITION.EXACT_STOPS.toString())) {      return getPathsWithExactStops(path, max);    } else if (type.equalsIgnoreCase(PATH_CONDITION.MAX_DISTANCE.toString())) {      return getPathsWithMaxDistance(path, max);    }    return "INVALID COMMAND INPUT";  }}