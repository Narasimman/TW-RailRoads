package com.thoughtworks.railroad.model;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.PriorityQueue;import java.util.Set;import com.thoughtworks.railroad.exception.NoSuchPathException;import com.thoughtworks.railroad.exception.NoSuchVertexException;import com.thoughtworks.railroad.model.condition.Condition;import com.thoughtworks.railroad.model.graph.IGraph;/** * Implementation of a Directed and weighted graph The graph contains a map of * vertex to the edges linked to them. The operations like * getAllPaths/getShortest path are implemented. Use these methods to get the * paths that obeys the condition filter that is being passed to them. *  * @author Narasimman *  */public class DirectedGraph implements IGraph {  private Map<Vertex, Set<Edge>> vertices;  public DirectedGraph() {    vertices = new HashMap<Vertex, Set<Edge>>();  }  @Override  public boolean addVertex(Vertex v) {    if (v == null) {      throw new NoSuchVertexException("null");    }    if (!vertices.containsKey(v)) {      vertices.put(v, new LinkedHashSet<Edge>());      return true;    }    return false;  }  @Override  public boolean addEdge(Vertex from, Vertex to, int weight) {    if (from == null || to == null) {      throw new NoSuchVertexException(from + " -> " + to);    }    Edge newEdge = new Edge(from, to, weight);    Set<Edge> sourceEdges = vertices.get(from);    if (sourceEdges.contains(newEdge)) {      sourceEdges.remove(newEdge);    }    return vertices.get(from).add(newEdge);  }  @Override  public int getNumberOfVertices() {    return vertices.size();  }  @Override  public String calculateDistance(Vertex from, Vertex[] stops) {    assertValidVertex(from);    if (stops.length < 1) {      throw new NoSuchPathException(stops.toString());    }    Vertex node = from;    int distance = 0;    for (int i = 0; i < stops.length; i++) {      Set<Edge> edges = vertices.get(node);      boolean validPath = false;      for (Edge edge : edges) {        Vertex stop = edge.getDestination();        if (stop.equals(stops[i])) {          validPath = true;          distance += edge.getDistance();          node = stops[i];          break;        }      }      if (!validPath) {        throw new NoSuchPathException(stops.toString());      }    }    return String.valueOf(distance);  }  @Override  public Path getShortestPath(Vertex from, Vertex to) {    return dijkstra(from, to);  }  @Override  public List<Path> getAllPaths(Vertex from, Vertex to,      Condition terminalCondition, Condition maxCondition) {    assertValidVertex(from);    assertValidVertex(to);    List<Path> paths = new ArrayList<Path>();    for (Edge edge : vertices.get(from)) {      Path path = Path.emptyPath();      path.addEdge(edge);      paths.addAll(depthFirstSearch(path, terminalCondition, maxCondition, to));    }    if (paths.isEmpty()) {      throw new NoSuchPathException(from.toString() + "--> " + to.toString());    }    return paths;  }  /**   * perform depth first search with the condition filter   *    * @param path   * @param validCondition   * @param terminalCondition   * @param end   * @return   */  private List<Path> depthFirstSearch(Path path, Condition validCondition,      Condition terminalCondition, Vertex end) {    List<Path> paths = new ArrayList<Path>();    if (terminalCondition.pass(path)) {      if (path.getLastNode().equals(end) && validCondition.pass(path))        paths.add(Path.copyPath(path));      for (Edge each : vertices.get(path.getLastNode())) {        path.addEdge(each);        paths.addAll(depthFirstSearch(path, validCondition, terminalCondition,            end));      }    }    path.removeLastEdge();    return paths;  }  /**   * Perform dijstra algorithm to find the shortest path given source and   * destination   *    * @param from   * @param to   * @return   */  private Path dijkstra(Vertex from, Vertex to) {    assertValidVertex(from);    assertValidVertex(to);    Map<Vertex, Path> paths = new HashMap<Vertex, Path>();    PriorityQueue<Path> q = new PriorityQueue<>();    Set<Vertex> unScanned = new HashSet<Vertex>();    unScanned.addAll(vertices.keySet());    for (Edge e : vertices.get(from)) {      Path path = Path.emptyPath();      path.addEdge(e);      q.add(path);      paths.put(e.getDestination(), path);    }    while (!q.isEmpty()) {      Path t = q.poll();      Vertex node = t.getLastNode();      unScanned.remove(node);      if (node == to)        return t;      int currDist = paths.get(node).getDistance();      for (Edge e : vertices.get(node)) {        Vertex targetNode = e.getDestination();        if (unScanned.contains(targetNode)) {          if (paths.get(targetNode) == null              || currDist + e.getDistance() < paths.get(targetNode)                  .getDistance()) {            Path newPath = Path.copyPath(t);            newPath.addEdge(e);            paths.put(e.getDestination(), newPath);            q.add(newPath);          }        }      }    }    Path shortestPath = paths.get(to);    if (shortestPath == null)      throw new NoSuchPathException(from.toString() + "->" + to.toString());    return shortestPath;  }  private void assertValidVertex(Vertex v) {    if (v == null || vertices.get(v) == null) {      throw new NoSuchVertexException(v.getName());    }  }  @Override  public String toString() {    StringBuilder sb = new StringBuilder();    for (Vertex v : vertices.keySet()) {      sb.append("<" + v.toString() + ">" + vertices.get(v) + "\n");    }    return sb.toString();  }}